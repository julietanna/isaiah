<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" version="1.1" viewBox="0 0 900 1400"
    xmlns="http://www.w3.org/2000/svg" 
    xmlns:xlink="http://www.w3.org/1999/xlink"
    onload="init()"
    onmouseup="mouseUp(evt)"
    onmousemove="mouseMove(evt)"
    >
<!--
    Testing Dragging of SVG Entities
    Copyright(c) 2005, Jeff Schiller
    
    - works in IE+ASV
    - works in Firefox 1.5
    - does NOT work in Opera 9 TP1
    
-->
<title>SVG Dragging</title>

    <style>.svg-clipped{-webkit-clip-path:url(#svgPath);clip-path:url(#svgPath);}</style>

<script><![CDATA[

    var draggingElement = null;
    var nMouseOffsetX = 0;
    var nMouseOffsetY = 0;
    
    function init() {
        //var ball = document.getElementById("ball");
        var square = document.getElementById("square");
        //var logo = document.getElementById("cd_logo");
        //var feed = document.getElementById("feed_icon");
        if(square) {
            //ball.addEventListener("mousedown", mouseDown, false);
            square.addEventListener("mousedown", mouseDown, false);
            //logo.addEventListener("mousedown", mouseDown, false);
            //feed.addEventListener("mousedown", mouseDown, false);
        }
        displayRawText("Drag square around");
    }
    
    function mouseDown(evt) { 
        var target = evt.currentTarget;
        draggingElement = target;

        if(target) {
            var p = document.documentElement.createSVGPoint();
            p.x = evt.clientX;
            p.y = evt.clientY;
        
            var m = getScreenCTM(document.documentElement);

            p = p.matrixTransform(m.inverse());
            nMouseOffsetX = p.x - parseInt(target.getAttribute("dragx"));
            nMouseOffsetY = p.y - parseInt(target.getAttribute("dragy"));
//            displayRawText("mouse offset=" + nMouseOffsetX + "," + nMouseOffsetY);
        }
    }
    function mouseUp(evt) { 
        draggingElement = null;
        nMouseOffsetX = 0;
        nMouseOffsetY = 0;
    }
    function mouseMove(evt) { 
        var p = document.documentElement.createSVGPoint();
        p.x = evt.clientX;
        p.y = evt.clientY;
        
        var m = getScreenCTM(document.documentElement);

        p = p.matrixTransform(m.inverse());
        p.x -= nMouseOffsetX;
        p.y -= nMouseOffsetY;
        
        if(draggingElement) {
            draggingElement.setAttribute("dragx", p.x);
            draggingElement.setAttribute("dragy", p.y);
            draggingElement.setAttribute("transform", "translate(" + p.x + "," + p.y + ")");
        }
        
        displayCoords(p.x, p.y, "(svg user)");
//        displayRawText("mouse offset=" + nMouseOffsetX + "," + nMouseOffsetY);
    }
    
    function displayCoords(x,y,extra) {
        var xNode = document.getElementById("xpos");
        var yNode = document.getElementById("ypos");
        if(xNode && yNode) {
            xNode.firstChild.nodeValue = parseInt(x) + extra;
            yNode.firstChild.nodeValue = parseInt(y) + extra;
        }
    }
    
    function displayRawText(text) {
        var textNode = document.getElementById("raw");
        if(textNode) {
            textNode.firstChild.nodeValue = text;
        }
    }
    
    function displayMatrix(matrix) {
        displayRawText(matrix.a + ", " + matrix.b + ", " + matrix.c + ", "
                        + matrix.d + ", " + matrix.e + ", " + matrix.f);
    }
    
    // Following is from Holger Will since ASV3 and O9 do not support getScreenTCM()
    // See http://groups.yahoo.com/group/svg-developers/message/50789
    function getScreenCTM(doc){
        if(doc.getScreenCTM) { return doc.getScreenCTM(); }
        
        var root=doc
        var sCTM= root.createSVGMatrix()

        var tr= root.createSVGMatrix()
        var par=root.getAttribute("preserveAspectRatio")
        if (par==null || par=="") par="xMidYMid meet"//setting to default value
        parX=par.substring(0,4) //xMin;xMid;xMax
        parY=par.substring(4,8)//YMin;YMid;YMax;
        ma=par.split(" ")
        mos=ma[1] //meet;slice

        //get dimensions of the viewport
        sCTM.a= 1
        sCTM.d=1
        sCTM.e= 0
        sCTM.f=0


        w=root.getAttribute("width")
        if (w==null || w=="") w=innerWidth

        h=root.getAttribute("height")
        if (h==null || h=="") h=innerHeight

        // Jeff Schiller:  Modified to account for percentages - I'm not 
        // absolutely certain this is correct but it works for 100%/100%
        if(w.substr(w.length-1, 1) == "%") {
            w = (parseFloat(w.substr(0,w.length-1)) / 100.0) * innerWidth;
        }
        if(h.substr(h.length-1, 1) == "%") {
            h = (parseFloat(h.substr(0,h.length-1)) / 100.0) * innerHeight;
        }

        // get the ViewBox
        vba=root.getAttribute("viewBox")
        if(vba==null) vba="0 0 "+w+" "+h
        var vb=vba.split(" ")//get the viewBox into an array

        //--------------------------------------------------------------------------
        //create a matrix with current user transformation
        tr.a= root.currentScale
        tr.d=root.currentScale
        tr.e= root.currentTranslate.x
        tr.f=root.currentTranslate.y


        //scale factors
        sx=w/vb[2]
        sy=h/vb[3]


        //meetOrSlice
        if(mos=="slice"){
        s=(sx>sy ? sx:sy)
        }else{
        s=(sx<sy ? sx:sy)
        }

        //preserveAspectRatio="none"
        if (par=="none"){
            sCTM.a=sx//scaleX
            sCTM.d=sy//scaleY
            sCTM.e=- vb[0]*sx //translateX
            sCTM.f=- vb[0]*sy //translateY
            sCTM=tr.multiply(sCTM)//taking user transformations into acount

            return sCTM
        }


        sCTM.a=s //scaleX
        sCTM.d=s//scaleY
        //-------------------------------------------------------
        switch(parX){
        case "xMid":
        sCTM.e=((w-vb[2]*s)/2) - vb[0]*s //translateX

        break;
        case "xMin":
        sCTM.e=- vb[0]*s//translateX
        break;
        case "xMax":
        sCTM.e=(w-vb[2]*s)- vb[0]*s //translateX
        break;
        }
        //------------------------------------------------------------
        switch(parY){
        case "YMid":
        sCTM.f=(h-vb[3]*s)/2 - vb[1]*s //translateY
        break;
        case "YMin":
        sCTM.f=- vb[1]*s//translateY
        break;
        case "YMax":
        sCTM.f=(h-vb[3]*s) - vb[1]*s //translateY
        break;
        }
        sCTM=tr.multiply(sCTM)//taking user transformations into acount

        return sCTM
    }

    function inspect(obj) {
        var str = new Array();
        var element = null;
        for(element in obj) { str[str.length] = element; }
        str.sort();
        alert(obj + ":" + str.join(' '));
    }
    
    

]]></script>

<!-- <image id="document" x="0" y="0" xlink:href="images/indenture.gif" width="900" height="1400" /> -->
<image x="0" y="0" xlink:href="images/indenture-lens-image.jpg" width="900" height="1400"/>
<image x="0" y="0" xlink:href="images/indenture-lens-text.jpg" width="900" height="1400" class="svg-clipped" />
<defs>
    <clipPath id="svgPath">
        <rect x="200" y="100" width="300" height="200" fill="white" stroke="black" stroke-width="3" />
    </clipPath>
</defs>



<g id="square" transform="translate(50,50)" dragx="50" dragy="50">
    <rect x="0" y="0" width="300" height="200" fill="white" stroke="black" stroke-width="3" />
</g>



<text x="600" y="100" font-size="20" fill="white">X:</text>
<text id="xpos" x="620" y="100" font-size="20" fill="white">0</text>

<text x="600" y="150" font-size="20" fill="white">Y:</text>
<text id="ypos" x="620" y="150" font-size="20" fill="white">0</text>

<text id="raw" x="600" y="200" font-size="20" fill="white"> </text>

</svg>
